# RISC-
Working of RISC pipeline

A RISC processor pipeline operates in much the same way, although the stages in the pipeline are different. While different processors have different numbers of steps, they are basically variations of these five, used in the MIPS R3000 processor:
1.	fetch instructions from memory
2.	read registers and decode the instruction
3.	execute the instruction or calculate an address
4.	access an operand in data memory
5.	write the result into a register
If you glance back at the diagram of the laundry pipeline, you'll notice that although the washer finishes in half an hour, the dryer takes an extra ten minutes, and thus the wet clothes must wait ten minutes for the dryer to free up. Thus, the length of the pipeline is dependent on the length of the longest step. Because RISC instructions are simpler than those used in pre-RISC processors (now called CISC, or Complex Instruction Set Computer), they are more conducive to pipelining. While CISC instructions varied in length, RISC instructions are all the same length and can be fetched in a single operation. Ideally, each of the stages in a RISC processor pipeline should take 1 clock cycle so that the processor finishes an instruction each clock cycle and averages one cycle per instruction (CPI).

About Project


Basic Structure Your task is to write a cycle-accurate simulator for the RiSC-16. At the start of the program, initialize the pc and all registers to zero. Initialize the instruction field in all pipeline registers to the nop instruction (0xe000). e main run() function will be a loop, where each iteration through the loop executes one cycle. At the beginning of the cycle, print the complete state of the machine (use the printState function at the end of this handout without modification). In the body of the loop, you will figure out what the new state of the machine (memory, registers, pipeline registers) will be at the end of the cycle. Conceptually all stages of the pipeline compute their new state simultaneously. Since statements execute sequentially in C rather than simultaneously, you will need two state variables: state and new. e variable state contains the state of the machine while the cycle is executing; the variable new will be the state of the ENEE 350: Computer Organization — Project 3 (10%) 4 machine at the end of the cycle. Each stage of the pipeline will modify the new variable using the current values in the state variable. E.g. in the ID stage, you will have a statement like new.IDEX.instr = state.IFID.instr; (to transfer the instruction in the IFID register to the IDEX register) In the body of loop, you will use new ONLY as the target of an assignment and you will use state ONLY as the source of an assignment (e.g. new... = state...). In general, state should never appear on the left-hand side of an assignment, and new should never appear on the right-hand side of an assignment. Your simulator must be pipelined. is means that the work of carrying out an instruction should be done in different stages of the pipeline as done in the textbook, and the execution of multiple instructions should be overlapped. e WB stage should be the only stage that writes to the register file; other stages should write to the pipeline registers. e ID stage should be the only stage that reads the register file; the other stages must get the register values from a pipeline register.

 It marks the end of the cycle and updates the current state with the values calculated in this cycle */ } Please use some sort of commenting like this so that we can easily identify what stages or your simulated pipeline are doing what. Without commenting, we will assume that everything happens all at once (i.e. no pipelining, therefore wrong). Halting At what point does the pipelined computer know to halt? It is incorrect to halt as soon as a halt instruction is fetched because if an earlier branch was actually taken, then the machine might actually branch around the halt instruction, in which it will be squashed and not executed. To solve this problem, halt the machine when a halt instruction reaches the MEMWB register. is ensures that previously executed instructions have completed, and it also ensures that the machine won’t branch around this halt. is solution is shown above; note how the final printState call before the check for halt will print the final state of the machine. ENEE 350: Computer Organization — Project 3 (10%) 5 Begin Your Implementation Assuming No Hazards e easiest way to start is to first write your simulator so that it does not account for data or branch hazards. is will allow you to get started right away. Of course, the simulator will only be able to correctly run assembly-language programs that have no hazards. It is thus the responsibility of the assembly-language programmer to insert nop instructions so that there are no data or branch hazards. is means putting a number of nops in an assembly-language program after a branch and a number of nops in an assembly-language program before a dependent data operation (it is a good exercise to figure out the minimum number needed in each situation). 



Finish Your Implementation by Accounting for Hazards Modifying your first implementation to account for data and branch hazards will probably be the hardest part of this assignment. Use data forwarding to resolve most data hazards. I.e. the ALU should be able to take its inputs from any pipeline register (instead of just the IDEX register). ere is no need for forwarding within the register file (as the book has). For this case of forwarding, you’ll instead forward data from the WBEND pipeline register. Remember to take the most recent data (e.g. data in the EXMEM register gets priority over data in the MEMWB register). Only forward data to the EX stage. You will need to stall for one type of data hazard: a lw followed by an instruction that uses the register being loaded. Static Branch Prediction Assume branch-not-taken for forward branches (those with a positive immediate value) and branchtaken for backward branches (those with a negative immediate value). is requires you to discard instructions if it turns out that the predicted direction was incorrect. To discard instructions, change the relevant fields in the pipeline to the nop instruction (0x0000). Running and Demonstrating Your Program Your simulator should be run using the same command format specified in Project 1, that is: simulate code > output I will give you skeleton code to use as a starting point. You should use the solution assembler from Project 1 to create the machine-code file that your simulator will run (since that’s how we’ll test it). Grading and Formatting We will grade almost solely on functionality. In particular, we will run your program on various assembly-language programs and check the contents of your memory, registers, and pipeline registers at each cycle. Most of these assembly-language programs will have hazards; a few will be hazard-free. Since we’ll be grading on getting the exact right answers (both at the end of the run and being cycleaccurate throughout the run), it behooves you to spend a lot of time writing test assembly-language programs and testing your program. Programs that are not doing exactly what they’re supposed to on every cycle will be penalized heavily, so check carefully. 


We will use a program to compare your output against a solution output. So it’s very important that you follow these exact formatting rules: 1. Don’t modify printState at all. ENEE 350: Computer Organization — Project 3 (10%) 6 2. ere should be ONLY ONE call to printState in your program. Do not put in any extra printState calls (you can put these in for debugging, but take them out before submitting the program). 3. Make sure to initialize all values correctly. a. state.numMemory should be set to the number of words in the machine-code file. b. state.cycles should be set to 0. c. pc and all registers should be set to 0. d. the instruction field in all pipeline registers should be set to the nop instruction. 4. Check your program’s output on the sample assembly-language programs and output that I will give you. Having events happen on the right cycle will also be very important (e.g. stall the exact number of cycles needed, write the branch target into the PC at exactly the right cycle, halt at the exact right cycle, stalling only when needed).
